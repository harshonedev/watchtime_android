# TV Authentication HTTP 500 Error - Fix Guide

## Problem Summary

The Android TV app is displaying "Authentication Error HTTP 500" when trying to authenticate. This error occurs during the initial QR code generation step when the TV app attempts to create an authentication session with the backend server.

## Root Cause

The HTTP 500 error is occurring because the TV authentication backend endpoints are **not yet implemented** on your server. The TV app is trying to call:

```
POST https://boc4cgg8sgkkgw84wk8gk80c.harshone.dev/api/auth/tv/create-session?sessionId={uuid}
```

But this endpoint either:
1. Doesn't exist on the backend
2. Is returning a server error (500)
3. The backend server is down or unreachable

## What I've Fixed in the Android App

I've improved the error handling and user experience:

### 1. Enhanced Error Logging
- Added detailed logging to `TvAuthViewModel` with the `TvAuthViewModel` tag
- Now logs all HTTP errors with specific error codes
- Logs network errors and connection issues
- You can now see detailed error information in Logcat

### 2. Better Error Messages
- HTTP 500: "Server error (HTTP 500). The backend authentication service may not be implemented yet."
- HTTP 404: "Authentication endpoint not found (HTTP 404)"
- Network errors: "Network connection error. Please check your internet connection."

### 3. Improved UI
- Added a retry button on the error screen
- Added troubleshooting tips for users
- Better visual design with error container and border
- More informative error display

## Required Backend Implementation

You need to implement the following endpoints on your backend server:

### 1. Create TV Auth Session

**Endpoint:** `POST /api/auth/tv/create-session`

**Query Parameters:**
- `sessionId` (string, required): UUID generated by the TV app

**Expected Response:**
```json
{
  "success": true,
  "data": {
    "sessionId": "550e8400-e29b-41d4-a716-446655440000",
    "authUrl": "watchtime://tv-auth?sessionId=550e8400-e29b-41d4-a716-446655440000",
    "expiresAt": 1638360000000
  }
}
```

**What it should do:**
- Create a temporary session record in your database/cache
- Generate an auth URL with the session ID
- Set expiration time (e.g., 10 minutes)
- Return the auth URL for QR code generation

### 2. Check TV Auth Status

**Endpoint:** `GET /api/auth/tv/check-status`

**Query Parameters:**
- `sessionId` (string, required): The session ID

**Expected Response (Not Authenticated):**
```json
{
  "success": true,
  "data": {
    "authenticated": false,
    "token": null,
    "userId": null
  }
}
```

**Expected Response (Authenticated):**
```json
{
  "success": true,
  "data": {
    "authenticated": true,
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "userId": "user-uuid-here"
  }
}
```

**What it should do:**
- Check if the session has been authenticated (linked from mobile)
- Return authentication status
- If authenticated, return the user's auth token

### 3. Link Mobile to TV

**Endpoint:** `POST /api/auth/tv/link`

**Headers:**
- `Authorization: Bearer <user_token>`

**Request Body:**
```json
{
  "sessionId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Expected Response:**
```json
{
  "success": true,
  "message": "TV authentication successful"
}
```

**What it should do:**
- Verify the user's token (from mobile app)
- Link the session to the authenticated user
- Update the session status to authenticated
- Store the user's token for the TV session

## Implementation Steps

### Option 1: Using Node.js/Express (Example)

```javascript
// auth-routes.js
const express = require('express');
const router = express.Router();

// In-memory session storage (use Redis or DB in production)
const tvSessions = new Map();

// Create TV auth session
router.post('/tv/create-session', async (req, res) => {
  try {
    const { sessionId } = req.query;
    
    if (!sessionId) {
      return res.status(400).json({
        success: false,
        error: 'Session ID is required'
      });
    }

    // Create session
    const session = {
      sessionId,
      authenticated: false,
      token: null,
      userId: null,
      expiresAt: Date.now() + (10 * 60 * 1000), // 10 minutes
      createdAt: Date.now()
    };

    tvSessions.set(sessionId, session);

    // Generate auth URL
    const authUrl = `watchtime://tv-auth?sessionId=${sessionId}`;

    res.json({
      success: true,
      data: {
        sessionId,
        authUrl,
        expiresAt: session.expiresAt
      }
    });
  } catch (error) {
    console.error('Error creating TV auth session:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create auth session'
    });
  }
});

// Check TV auth status
router.get('/tv/check-status', async (req, res) => {
  try {
    const { sessionId } = req.query;
    
    if (!sessionId) {
      return res.status(400).json({
        success: false,
        error: 'Session ID is required'
      });
    }

    const session = tvSessions.get(sessionId);

    if (!session) {
      return res.status(404).json({
        success: false,
        error: 'Session not found'
      });
    }

    // Check if expired
    if (Date.now() > session.expiresAt) {
      tvSessions.delete(sessionId);
      return res.status(410).json({
        success: false,
        error: 'Session expired'
      });
    }

    res.json({
      success: true,
      data: {
        authenticated: session.authenticated,
        token: session.token,
        userId: session.userId
      }
    });
  } catch (error) {
    console.error('Error checking TV auth status:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to check auth status'
    });
  }
});

// Link mobile to TV
router.post('/tv/link', async (req, res) => {
  try {
    const { sessionId } = req.body;
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: 'Authorization required'
      });
    }

    const token = authHeader.substring(7);
    
    // Verify token and get user (implement your auth logic here)
    // const user = await verifyToken(token);

    const session = tvSessions.get(sessionId);

    if (!session) {
      return res.status(404).json({
        success: false,
        error: 'Session not found'
      });
    }

    if (Date.now() > session.expiresAt) {
      tvSessions.delete(sessionId);
      return res.status(410).json({
        success: false,
        error: 'Session expired'
      });
    }

    // Link the session
    session.authenticated = true;
    session.token = token;
    // session.userId = user.id;

    tvSessions.set(sessionId, session);

    res.json({
      success: true,
      message: 'TV authentication successful'
    });
  } catch (error) {
    console.error('Error linking TV auth:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to link authentication'
    });
  }
});

module.exports = router;
```

### Option 2: Using Python/Flask (Example)

```python
from flask import Blueprint, request, jsonify
from datetime import datetime, timedelta
import uuid

auth_bp = Blueprint('auth', __name__)

# In-memory session storage (use Redis or DB in production)
tv_sessions = {}

@auth_bp.route('/tv/create-session', methods=['POST'])
def create_tv_session():
    try:
        session_id = request.args.get('sessionId')
        
        if not session_id:
            return jsonify({
                'success': False,
                'error': 'Session ID is required'
            }), 400

        # Create session
        session = {
            'sessionId': session_id,
            'authenticated': False,
            'token': None,
            'userId': None,
            'expiresAt': int((datetime.now() + timedelta(minutes=10)).timestamp() * 1000),
            'createdAt': int(datetime.now().timestamp() * 1000)
        }

        tv_sessions[session_id] = session

        # Generate auth URL
        auth_url = f'watchtime://tv-auth?sessionId={session_id}'

        return jsonify({
            'success': True,
            'data': {
                'sessionId': session_id,
                'authUrl': auth_url,
                'expiresAt': session['expiresAt']
            }
        })
    except Exception as e:
        print(f'Error creating TV auth session: {e}')
        return jsonify({
            'success': False,
            'error': 'Failed to create auth session'
        }), 500

@auth_bp.route('/tv/check-status', methods=['GET'])
def check_tv_status():
    try:
        session_id = request.args.get('sessionId')
        
        if not session_id:
            return jsonify({
                'success': False,
                'error': 'Session ID is required'
            }), 400

        session = tv_sessions.get(session_id)

        if not session:
            return jsonify({
                'success': False,
                'error': 'Session not found'
            }), 404

        # Check if expired
        if datetime.now().timestamp() * 1000 > session['expiresAt']:
            del tv_sessions[session_id]
            return jsonify({
                'success': False,
                'error': 'Session expired'
            }), 410

        return jsonify({
            'success': True,
            'data': {
                'authenticated': session['authenticated'],
                'token': session['token'],
                'userId': session['userId']
            }
        })
    except Exception as e:
        print(f'Error checking TV auth status: {e}')
        return jsonify({
            'success': False,
            'error': 'Failed to check auth status'
        }), 500

@auth_bp.route('/tv/link', methods=['POST'])
def link_tv_auth():
    try:
        data = request.get_json()
        session_id = data.get('sessionId')
        auth_header = request.headers.get('Authorization')

        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({
                'success': False,
                'error': 'Authorization required'
            }), 401

        token = auth_header[7:]
        
        session = tv_sessions.get(session_id)

        if not session:
            return jsonify({
                'success': False,
                'error': 'Session not found'
            }), 404

        if datetime.now().timestamp() * 1000 > session['expiresAt']:
            del tv_sessions[session_id]
            return jsonify({
                'success': False,
                'error': 'Session expired'
            }), 410

        # Link the session
        session['authenticated'] = True
        session['token'] = token

        tv_sessions[session_id] = session

        return jsonify({
            'success': True,
            'message': 'TV authentication successful'
        })
    except Exception as e:
        print(f'Error linking TV auth: {e}')
        return jsonify({
            'success': False,
            'error': 'Failed to link authentication'
        }), 500
```

## Testing the Fix

### 1. Check Logcat
Run the TV app and check Logcat with the filter `TvAuthViewModel`:

```bash
adb logcat -s TvAuthViewModel
```

You should see detailed error information about what's failing.

### 2. Test with cURL

Once you implement the endpoints, test them:

```bash
# Create session
curl -X POST "http://localhost:5000/api/auth/tv/create-session?sessionId=test-123"

# Check status
curl "http://localhost:5000/api/auth/tv/check-status?sessionId=test-123"

# Link (replace YOUR_TOKEN with actual token)
curl -X POST "http://localhost:5000/api/auth/tv/link" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"sessionId":"test-123"}'
```

### 3. Update Base URL

Make sure your backend is running and accessible at:
```
https://boc4cgg8sgkkgw84wk8gk80c.harshone.dev/api/
```

This is configured in: `/core/utils/src/main/java/com/app/core/utils/constants/Constants.kt`

## Quick Checklist

- [ ] Backend server is running
- [ ] Backend is accessible from TV device
- [ ] `/api/auth/tv/create-session` endpoint is implemented
- [ ] `/api/auth/tv/check-status` endpoint is implemented
- [ ] `/api/auth/tv/link` endpoint is implemented
- [ ] All endpoints return correct JSON format
- [ ] CORS is configured if needed
- [ ] SSL/HTTPS is working properly

## Alternative Workaround (For Testing)

If you want to test the TV app without implementing the backend first, you can:

1. Create a mock implementation that returns hardcoded responses
2. Use a local mock server like `json-server`
3. Modify the TV app to skip authentication temporarily

Let me know if you need help with any of these options!

## References

- TV Implementation docs: `TV_IMPLEMENTATION.md`
- API documentation: `API_DOCS.md`
- Architecture diagram: `TV_ARCHITECTURE_DIAGRAM.md`

